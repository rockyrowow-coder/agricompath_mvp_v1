-- ULTIMATE SETUP SCRIPT (Phase 1 + Phase 2)
-- Run this to set up the entire database from scratch or update an existing one.

-- ==========================================
-- PART 1: Core Tables (Records, Inventory)
-- ==========================================

-- Create records table
create table if not exists records (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  user_id uuid references auth.users not null,
  date text,
  type text,
  crop text,
  detail text,
  amount text,
  field text,
  time_start text,
  time_end text,
  range text,
  pesticide text,
  work_type text,
  memo text,
  images text[],
  is_public boolean default false -- Added for sharing
);

-- Create inventory table
create table if not exists inventory (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  user_id uuid references auth.users not null,
  name text,
  category text,
  quantity numeric,
  unit text
);

-- Enable RLS for Core Tables
alter table records enable row level security;
alter table inventory enable row level security;

-- Policies for records
-- Note: complex policies like "view shared" created later. Basic own-data policies here.
drop policy if exists "Users can view their own records" on records;
create policy "Users can view their own records" on records for select using (auth.uid() = user_id);

drop policy if exists "Users can insert their own records" on records;
create policy "Users can insert their own records" on records for insert with check (auth.uid() = user_id);

drop policy if exists "Users can update their own records" on records;
create policy "Users can update their own records" on records for update using (auth.uid() = user_id);

drop policy if exists "Users can delete their own records" on records;
create policy "Users can delete their own records" on records for delete using (auth.uid() = user_id);


-- Policies for inventory
drop policy if exists "Users can view their own inventory" on inventory;
create policy "Users can view their own inventory" on inventory for select using (auth.uid() = user_id);

drop policy if exists "Users can insert their own inventory" on inventory;
create policy "Users can insert their own inventory" on inventory for insert with check (auth.uid() = user_id);

drop policy if exists "Users can update their own inventory" on inventory;
create policy "Users can update their own inventory" on inventory for update using (auth.uid() = user_id);


-- ==========================================
-- PART 2: Community Tables
-- ==========================================

-- Create communities table
create table if not exists communities (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  name text not null,
  description text,
  created_by uuid references auth.users not null,
  image_url text,
  rep_email text,
  rep_phone text,
  rep_ja_number text
);

-- Create community_members table
create table if not exists community_members (
  id bigint generated by default as identity primary key,
  joined_at timestamp with time zone default timezone('utc'::text, now()) not null,
  community_id bigint references communities on delete cascade not null,
  user_id uuid references auth.users not null,
  role text default 'member', -- 'admin', 'member'
  unique(community_id, user_id)
);

-- Create community_posts table
create table if not exists community_posts (
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  community_id bigint references communities on delete cascade not null,
  user_id uuid references auth.users not null,
  content text,
  image_url text
);

-- Create record_shares table
create table if not exists record_shares (
  id bigint generated by default as identity primary key,
  shared_at timestamp with time zone default timezone('utc'::text, now()) not null,
  record_id bigint references records on delete cascade not null,
  community_id bigint references communities on delete cascade not null,
  unique(record_id, community_id)
);

-- Enable RLS for Community Tables
alter table communities enable row level security;
alter table community_members enable row level security;
alter table community_posts enable row level security;
alter table record_shares enable row level security;


-- Policies for communities
drop policy if exists "Communities are viewable by everyone" on communities;
create policy "Communities are viewable by everyone" on communities for select using (true);

drop policy if exists "Authenticated users can create communities" on communities;
create policy "Authenticated users can create communities" on communities for insert with check (auth.role() = 'authenticated');

drop policy if exists "Admins can update their communities" on communities;
create policy "Admins can update their communities" on communities for update using (auth.uid() = created_by);

-- Policies for community_members
drop policy if exists "Members are viewable by everyone" on community_members;
create policy "Members are viewable by everyone" on community_members for select using (true);

drop policy if exists "Users can join communities" on community_members;
create policy "Users can join communities" on community_members for insert with check (auth.uid() = user_id);

drop policy if exists "Users can leave communities" on community_members;
create policy "Users can leave communities" on community_members for delete using (auth.uid() = user_id);

-- Policies for community_posts
drop policy if exists "Members can view posts" on community_posts;
create policy "Members can view posts" on community_posts for select using (
  exists (
    select 1 from community_members
    where community_members.community_id = community_posts.community_id
    and community_members.user_id = auth.uid()
  )
);

drop policy if exists "Members can create posts" on community_posts;
create policy "Members can create posts" on community_posts for insert with check (
  exists (
    select 1 from community_members
    where community_members.community_id = community_posts.community_id
    and community_members.user_id = auth.uid()
  )
);

-- Policies for record_shares
drop policy if exists "Users can see shares for communities they are in" on record_shares;
create policy "Users can see shares for communities they are in" on record_shares for select using (
  exists (
    select 1 from community_members
    where community_members.community_id = record_shares.community_id
    and community_members.user_id = auth.uid()
  )
  or
  exists (
    select 1 from records
    where records.id = record_shares.record_id
    and records.user_id = auth.uid()
  )
);

drop policy if exists "Users can share their own records" on record_shares;
create policy "Users can share their own records" on record_shares for insert with check (
  exists (
    select 1 from records
    where records.id = record_shares.record_id
    and records.user_id = auth.uid()
  )
);

-- Extra Policies for Records (Sharing Visibility)
drop policy if exists "Users can view public records" on records;
create policy "Users can view public records" on records for select using (is_public = true);

drop policy if exists "Users can view records shared to their communities" on records;
create policy "Users can view records shared to their communities" on records for select using (
  exists (
    select 1 from record_shares
    join community_members on record_shares.community_id = community_members.community_id
    where record_shares.record_id = records.id
    and community_members.user_id = auth.uid()
  )
);


-- ==========================================
-- PART 3: Storage
-- ==========================================

-- Policies for 'images' bucket
-- Note: You should CREATE the 'images' bucket in the Supabase Dashboard first if it doesn't exist.
drop policy if exists "Public Access" on storage.objects;
create policy "Public Access"
  on storage.objects for select
  using ( bucket_id = 'images' );

drop policy if exists "Authenticated Upload" on storage.objects;
create policy "Authenticated Upload"
  on storage.objects for insert
  to authenticated
  with check ( bucket_id = 'images' );


-- ==========================================
-- PART 4: Seed Data
-- ==========================================

-- ==========================================
-- PART 4: Seed Data
-- ==========================================

-- Insert a dummy community (Moriyama Melon Department)
insert into communities (name, description, created_by, rep_email, rep_phone, rep_ja_number)
select '守山メロン部会', '守山名産のメロン栽培農家の集まりです。品質向上とブランド化を目指して活動しています。', (select id from auth.users limit 1), 'melon_rep@example.com', '077-582-1111', '99887766'
from auth.users
where not exists (select 1 from communities where name = '守山メロン部会')
limit 1;

-- Insert another dummy community (Generic Guild)
insert into communities (name, description, created_by, rep_email, rep_phone, rep_ja_number)
select 'Glowthユーザーギルド', 'アプリ利用者の情報交換コミュニティ。機能要望や使い方の相談など。', (select id from auth.users limit 1), 'support@glowth.jp', '03-1234-5678', '11223344'
from auth.users
where not exists (select 1 from communities where name = 'Glowthユーザーギルド')
limit 1;


-- Insert a dummy post
insert into community_posts (community_id, user_id, content, created_at)
select id, (select id from auth.users limit 1), '今年の出荷基準が決まりました。資料を確認してください。', now()
from communities
where name = '守山メロン部会'
limit 1;

-- Insert dummy records (Melon)
insert into records (user_id, date, type, crop, detail, amount, time_start, time_end, status, is_public)
select id, current_date, 'work', 'メロン', '整枝作業', '3時間', '07:00', '10:00', 'done', true
from auth.users
limit 1;

insert into records (user_id, date, type, crop, detail, amount, status, is_public)
select id, current_date - 1, 'fertilizer', 'メロン', '追肥 (アミノ酸)', '20kg', 'done', true
from auth.users
limit 1;
